# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Essential Commands

### Development Workflow

```bash
# Start development server with hot reload
pnpm dev

# Build for production (includes astro check)
pnpm build

# Preview production build locally
pnpm preview
```

### Code Quality Pipeline

Run these commands in order after development work:

```bash
# 1. Lint code with @nextnode/eslint-plugin
pnpm lint

# 2. Type checking (Astro + TypeScript)
pnpm type-check

# 3. Run test suite
pnpm test

# 4. Test with coverage reports
pnpm test:coverage
```

### Testing Commands

```bash
# Watch mode for active development
pnpm test:watch

# Interactive test UI
pnpm test:ui

# Fast type check (skips astro check)
pnpm type-check:fast
```

## Architecture Overview

### Core Technology Stack

- **Astro 5.x** with React integration for selective hydration
- **Tailwind CSS v4** for styling with design tokens
- **TypeScript** in strict mode throughout
- **Vitest** for testing with jsdom environment
- **Node.js adapter** for standalone server deployment

### Key Architectural Patterns

#### 1. Internationalization (i18n) System

- **Manual routing**: URLs like `/en/page` and `/fr/page`
- **Middleware-driven**: `src/middleware.ts` handles locale detection and URL mapping
- **Unified t() function**: Works both server-side (Astro) and client-side (React)
- **Translation files**: Structured dictionaries in `src/i18n/locales/`
- **Context injection**: Middleware injects `locale` and `t` into `context.locals`

#### 2. Configuration Management

- **Environment-based configs**: JSON files in `config/{dev,prod,test}.json`
- **Type-safe access**: Via `src/lib/config/` with dot notation (`getConfig('email.from')`)
- **Runtime loading**: Dynamic config resolution based on NODE_ENV

#### 3. Component Organization

```
src/components/
├── common/          # Shared utility components
├── features/        # Business logic components
│   ├── marketing/   # Marketing-related features
│   ├── workflow/    # Complex workflow visualizations
│   └── pricing/     # Pricing page components
├── layout/          # Header, footer, navigation
└── ui/             # Base design system components
```

#### 4. State Management

- **React hooks**: Custom hooks in `src/hooks/` for client-side state
- **Modal management**: Centralized modal state with `useModalState`
- **Keyboard shortcuts**: `useKeyboardShortcuts` for accessibility
- **No external state library**: Pure React patterns

#### 5. Email System

- **React Email**: Components in `emails/` directory
- **Resend integration**: Production email delivery
- **Template system**: Reusable email components with type safety
- **API endpoint**: `/api/send-email.ts` for form submissions

#### 6. SEO & Local Search Optimization

- **Automatic Sitemap**: Generated by @astrojs/sitemap with custom SEO priorities for Paris local search
    - French pages prioritized (1.0 for homepage, 0.9 for pricing, 0.8 for how-we-work)
    - English pages as secondary market (0.7, 0.6, 0.5 respectively)
    - Automatic i18n hreflang attributes for bilingual SEO
    - Custom changefreq settings (weekly for homepage, monthly for main pages, yearly for legal)
- **Schema.org**: LocalBusiness data optimized for Paris/Île-de-France market
- **Meta optimization**: Centralized SEO component with locale-specific content
- **Local targeting**: Paris coordinates, service areas, and French market focus
- **Robots.txt**: Optimized crawl directives for French search engines

### Performance Optimizations

#### Bundle Splitting (astro.config.mjs)

- **Vendor chunks**: React, Radix UI, utilities separated
- **Feature-based splitting**: Workflow and marketing components
- **Icon isolation**: Lucide React in separate chunk

#### SSR + Selective Hydration

- **Server-side rendering** for initial page load
- **Client components** only when interactivity needed
- **Progressive enhancement** approach

### Development Patterns

#### Import Standards

- **ES modules only**: Never use `require()`
- **Arrow functions**: `const fn = () => {}` preferred
- **Destructuring**: Used extensively for clean code
- **Strong typing**: No `any` types allowed, minimal `unknown`

#### Component Patterns

- **Astro components**: `.astro` for static/SSR content
- **React components**: `.tsx` for interactive features
- **Props interfaces**: Defined per component with TypeScript
- **Tailwind composition**: Design tokens via CSS custom properties

#### CSS & Animation Standards

- **Keyframe animations**: MUST be placed in dedicated CSS files, NEVER inline in `.astro` components
- **Animation organization**: Keep animations modular and reusable in separate stylesheets
- **Tailwind animations**: Prefer Tailwind utilities when possible; use custom CSS only when necessary

#### Testing Strategy

- **Component testing**: React Testing Library + Vitest
- **Integration tests**: For complex features like workflow journey
- **Type testing**: Via TypeScript compilation
- **Coverage tracking**: V8 provider with JSON output
- **Test colocation**: Tests placed in `__tests__/` folders next to implementation
- **Test helpers**: Shared mocks and utilities in dedicated helper files

## Advanced Architectural Patterns

### Cookie Management System

The project uses a **Strategy Pattern** for type-safe cookie management:

- **Automatic strategy selection**: Cookie Store API (HTTPS) with document.cookie fallback (HTTP/localhost)
- **Factory pattern**: `createCookieStrategy()` detects environment and selects appropriate implementation
- **Type-safe API**: Consistent interface regardless of underlying implementation
- **Server-side support**: Separate `createServerCookieManager()` for Astro middleware
- **Location**: `src/lib/cookies/` with dedicated strategy files

**Key files:**

- `factory.ts`: Strategy factory with protocol detection
- `cookie-store-strategy.ts`: Modern Cookie Store API implementation
- `document-cookie-strategy.ts`: Legacy fallback implementation
- `server.ts`: Server-side cookie management for middleware
- `__tests__/`: Comprehensive test suite with mock helpers

### Client-Side State Management

**Theme Manager** (`src/lib/client/theme-manager.ts`):

- Theme detection from cookie or system preference
- Global state via `window.currentTheme` and `window.initialTheme`
- SSR-safe with middleware injection (`locals.theme`)
- Custom event dispatching (`theme-changed`) for React components
- Automatic icon updates across all theme toggle buttons

**Language Manager** (`src/lib/client/language-manager.ts`):

- Dynamic URL generation based on `SUPPORTED_LOCALES`
- Cookie persistence before navigation
- HTML `lang` attribute synchronization
- Event delegation for language selector buttons
- Integration with i18n middleware

### Configuration Architecture

**Two-tier configuration system:**

#### 1. Config Files (Dynamic Values)

Pattern: `src/lib/config/**/*-config.ts`

- **Animation configs**: Timing, delays, keyframe values, observer settings
- **Component configs**: Tech orbits, transformation beams, workflow animations
- **Naming convention**: `*-config.ts` for centralized configuration objects
- **Usage**: Import constants for consistent animations and behaviors

**Examples:**

- `marketing/tech-animation-config.ts`: OBSERVER_CONFIG, ANIMATION_DURATIONS, KEYFRAME_VALUES
- `marketing/orbiting-tech-config.ts`: Icon positions, animation parameters
- `workflow/workflow-animation-config.ts`: Journey timeline configuration

#### 2. UI Constants (Reusable Patterns)

Pattern: `src/lib/ui/*-constants.ts`

- **CSS patterns**: Pre-composed Tailwind classes with `cn()` utility
- **Reusable styles**: Cards, gradients, typography, spacing
- **Design tokens**: Consistent visual patterns across components
- **Type-safe**: Constants exported with `as const` for literal types

**Example:** `marketing-constants.ts`

```typescript
export const MARKETING_CARDS = {
	container: cn(
		'rounded-3xl p-8 sm:p-10',
		'bg-white/50 dark:bg-brand-charcoal/50',
		'backdrop-blur-sm',
	),
} as const
```

### Animation System Architecture

**Observer-based animation triggers:**

1. **Keyframe definitions**: All `@keyframes` in `src/styles/animations.css`
2. **Configuration**: Centralized in `*-animation-config.ts` files
3. **Observer logic**: Dedicated TypeScript files (e.g., `TechTransformationObserver.ts`)
4. **Execution flow**:
    - Component adds `data-delay` attributes to elements
    - Observer script watches section visibility (IntersectionObserver)
    - Classes toggled: `.tech-animate` → `.tech-animating` → `.tech-animated`
    - Configuration values imported from central config

**Key principles:**

- **NEVER** define keyframes inline in `.astro` components
- **ALWAYS** use dedicated CSS files for animations
- **ALWAYS** centralize timing/delay values in config files
- **Use** IntersectionObserver for scroll-triggered animations
- **Extract** observer logic to separate TypeScript modules

### Middleware Modularity

The middleware system follows **single responsibility principle**:

**Core middleware modules** (`src/lib/middleware/`):

- `i18n.ts`: Locale detection and translation context injection
- `url-mapping.ts`: Route normalization and locale prefix handling
- `logging.ts`: Structured request/response logging with correlation IDs
- `metrics.ts`: Performance tracking and analytics
- `theme.ts`: Theme preference detection and SSR injection
- `utils.ts`: Shared helpers (cookie parsing, validation, request filtering)

**Request flow:**

1. URL processing → locale extraction
2. Theme detection → `locals.theme` injection
3. I18n setup → `locals.t` and `locals.locale` injection
4. Metrics collection → performance tracking
5. Logging → structured output

## Environment Configuration

### Required Environment Variables

- `HOST`: Server host (default: 0.0.0.0)
- `PORT`: Server port (default: 4321)
- `URL`: Public site URL for canonical links

### Config Files Structure

```
config/
├── default.json     # Base configuration
├── dev.json         # Development overrides
├── prod.json        # Production settings
└── test.json        # Test environment
```

### TypeScript Definitions Structure

```
types/
├── config.d.ts      # Configuration type definitions
├── env.d.ts         # Environment and Astro global types
├── global.d.ts      # Global type definitions
└── plans.ts         # Pricing plan type definitions
```

### SEO & Logging Structure

```
src/lib/
├── seo/
│   └── schema.ts    # Schema.org structured data utilities
└── logging/
    └── index.ts     # NextNode logger instances (astroLogger, etc.)
```

## Common Development Workflows

### Adding New Features

1. Create components in appropriate `src/components/features/` subdirectory
2. Add translations to both `en/` and `fr/` locale files
3. Update routing in `src/pages/[locale]/` if needed
4. Add tests in same directory as component
5. Run quality pipeline: `pnpm lint && pnpm type-check && pnpm test`

### Internationalization Updates

- Edit `src/i18n/locales/{en,fr}/` dictionary files
- Use dot notation keys (e.g., `home.hero.title`)
- Test with both `/en/` and `/fr/` URL prefixes
- Verify middleware locale detection works correctly

### Email Template Development

1. Create React Email component in `emails/` directory
2. Add to template exports in `src/lib/email/templates/index.ts`
3. Test rendering via `/api/send-email` endpoint
4. Configure Resend API key for production

### SEO Configuration and Optimization

#### Using the SEO Component

All pages should use the centralized SEO component via BaseLayout:

```astro
---
const title = t('common.meta.homepage.title')
const description = t('common.meta.homepage.description')
---

<BaseLayout title={title} description={description} type="website">
	<!-- Page content -->
</BaseLayout>
```

#### Adding New Page SEO

1. Add meta translations to `src/i18n/locales/{en,fr}/common.ts`:

    ```typescript
    meta: {
      newPage: {
        title: 'Page Title | NextNode - Agence Web Paris',
        description: 'SEO-optimized description with Paris keywords...'
      }
    }
    ```

2. Use in page component:
    ```astro
    const title = t('common.meta.newPage.title') const description =
    t('common.meta.newPage.description')
    ```

#### Schema.org Updates

- Edit `src/lib/seo/schema.ts` for structured data changes
- LocalBusiness schema covers Paris/Île-de-France service area
- Automatically injected in all pages via SEO component
- Supports both French and English locales

## Critical Implementation Details

### Middleware Architecture (Recently Refactored)

The middleware system has been decomposed into specialized modules in `src/lib/middleware/`:

#### Core Middleware Modules

1. **`i18n.ts`**: Internationalization handling
    - Locale detection from URL path and Accept-Language header
    - Translation context setup for both Astro and React components
    - Fallback locale management

2. **`url-mapping.ts`**: URL path processing
    - Route mapping and normalization
    - Locale prefix handling (`/en/`, `/fr/`)
    - Internal navigation and redirects

3. **`logging.ts`**: Request/response logging
    - Structured request logging with correlation IDs
    - Error tracking and performance monitoring
    - Integration with @nextnode/logger

4. **`metrics.ts`**: Performance metrics collection
    - Page view tracking
    - Response time measurement
    - User interaction analytics

5. **`utils.ts`**: Shared middleware utilities
    - Common helper functions
    - Validation and parsing utilities
    - Error handling patterns

#### Middleware Request Flow

1. **URL processing**: Route normalization and locale extraction
2. **I18n setup**: Language detection and translation context injection
3. **Metrics collection**: Performance tracking and analytics
4. **Logging**: Structured request/response logging
5. **Context injection**: Middleware injects `locale` and `t` into `context.locals`

### Workflow Journey Component

- **Complex interactive visualization** in `src/components/features/workflow/`
- **SVG animations** with coordinated state management
- **Modal system** for step details with keyboard navigation
- **Mobile responsive** with separate timeline component

### Build Process

1. `astro check` validates Astro components and routing
2. TypeScript compilation with strict mode (types/ directory)
3. Tailwind CSS v4 processing with design tokens
4. Vite bundling with custom chunk strategy
5. Node.js adapter for standalone deployment

### Deployment Configuration

#### Railway Platform

- **Configuration**: `railway.toml` with Docker builder
- **Health checks**: Built-in endpoint monitoring at `/`
- **Restart policies**: Automatic failure recovery
- **Environment**: Production-optimized settings
- **Watch patterns**: Optimized file change detection

#### Docker Multi-stage Build

- **Base stage**: Node.js environment setup
- **Build stage**: Dependency installation and compilation
- **Production stage**: Optimized runtime with minimal footprint
- **Health check**: Integrated container health monitoring

# important-instruction-reminders

Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (\*.md) or README files. Only create documentation files if explicitly requested by the User.
